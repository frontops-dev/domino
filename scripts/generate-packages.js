#!/usr/bin/env node

const fs = require('fs')
const path = require('path')

const REPO_ROOT = path.resolve(__dirname, '..')
const NPM_DIR = path.join(REPO_ROOT, 'npm')
const ARTIFACTS_DIR = path.join(REPO_ROOT, 'artifacts')
const BIN_NAME = 'domino'
const PKG_NAME = '@front-ops/domino'

const TARGET_TO_PACKAGE = {
  'x86_64-apple-darwin': {
    name: 'darwin-x64',
    binary: 'domino',
    ext: '',
  },
  'aarch64-apple-darwin': {
    name: 'darwin-arm64',
    binary: 'domino',
    ext: '',
  },
  'x86_64-pc-windows-msvc': {
    name: 'win32-x64-msvc',
    binary: 'domino.exe',
    ext: '.exe',
  },
  'x86_64-unknown-linux-gnu': {
    name: 'linux-x64-gnu',
    binary: 'domino',
    ext: '',
  },
  'x86_64-unknown-linux-musl': {
    name: 'linux-x64-musl',
    binary: 'domino',
    ext: '',
  },
  'aarch64-unknown-linux-musl': {
    name: 'linux-arm64-musl',
    binary: 'domino',
    ext: '',
  },
}

function readRootPackageJson() {
  const pkgPath = path.join(REPO_ROOT, 'package.json')
  return JSON.parse(fs.readFileSync(pkgPath, 'utf8'))
}

function findArtifact(target) {
  const artifactDir = path.join(ARTIFACTS_DIR, `bindings-${target}`)
  if (!fs.existsSync(artifactDir)) {
    return null
  }

  const files = fs.readdirSync(artifactDir)
  const nodeFile = files.find((file) => file.endsWith('.node'))
  const binaryFile = files.find((file) => file.startsWith(`${BIN_NAME}-${target}`))

  return {
    dir: artifactDir,
    node: nodeFile ? path.join(artifactDir, nodeFile) : null,
    binary: binaryFile ? path.join(artifactDir, binaryFile) : null,
  }
}

function generatePackageJson(target, targetInfo, rootManifest, nodeFileName) {
  const packageName = `${PKG_NAME}-${targetInfo.name}`
  const triple = targetInfo.name.split('-')
  const platform = triple[0]
  const arch = triple[1]
  const libc = triple[2] && { libc: [triple[2] === 'gnu' ? 'glibc' : 'musl'] }

  const { version, author, license, homepage, bugs, repository } = rootManifest

  const manifest = {
    name: packageName,
    version,
    type: 'commonjs',
    main: nodeFileName,
    author,
    license,
    homepage,
    bugs,
    repository,
    os: [platform],
    cpu: [arch],
    ...libc,
    publishConfig: {
      executableFiles: [targetInfo.binary],
    },
    files: [nodeFileName, targetInfo.binary],
  }

  return manifest
}

function main() {
  const rootPkg = readRootPackageJson()
  const version = rootPkg.version

  if (!fs.existsSync(NPM_DIR)) {
    fs.mkdirSync(NPM_DIR, { recursive: true })
  }

  for (const [target, targetInfo] of Object.entries(TARGET_TO_PACKAGE)) {
    const artifact = findArtifact(target)
    if (!artifact) {
      console.warn(`Warning: Artifact not found for ${target}, skipping`)
      continue
    }

    if (!artifact.node) {
      console.warn(`Warning: .node file not found in artifact for ${target}, skipping`)
      continue
    }

    if (!artifact.binary) {
      console.warn(`Warning: Binary not found in artifact for ${target}, skipping`)
      continue
    }

    const packageRoot = path.join(NPM_DIR, targetInfo.name)

    // Remove the directory just in case it already exists (it's autogenerated)
    if (fs.existsSync(packageRoot)) {
      fs.rmSync(packageRoot, { recursive: true, force: true })
    }

    // Create the package directory
    console.log(`Create directory ${packageRoot}`)
    fs.mkdirSync(packageRoot, { recursive: true })

    // Copy the .node file
    const nodeFileName = path.basename(artifact.node)
    const nodeDest = path.join(packageRoot, nodeFileName)
    fs.copyFileSync(artifact.node, nodeDest)
    console.log(`✓ Copied ${nodeFileName} to ${targetInfo.name}`)

    // Copy the binary
    const binaryDest = path.join(packageRoot, targetInfo.binary)
    fs.copyFileSync(artifact.binary, binaryDest)
    if (!targetInfo.ext) {
      fs.chmodSync(binaryDest, 0o755)
    }
    console.log(`✓ Copied ${targetInfo.binary} to ${targetInfo.name}`)

    // Generate package.json
    const manifest = generatePackageJson(target, targetInfo, rootPkg, nodeFileName)
    const manifestPath = path.join(packageRoot, 'package.json')
    fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2) + '\n')
    console.log(`✓ Generated package.json for ${targetInfo.name}`)
  }

  // Update the main package.json with optionalDependencies (like oxc does)
  const mainManifestPath = path.join(REPO_ROOT, 'package.json')
  const mainManifest = JSON.parse(fs.readFileSync(mainManifestPath, 'utf8'))

  const nativePackages = Object.values(TARGET_TO_PACKAGE).map((targetInfo) => [
    `${PKG_NAME}-${targetInfo.name}`,
    version,
  ])

  // Merge with existing optionalDependencies to preserve @oxc-node packages
  mainManifest.optionalDependencies = {
    ...mainManifest.optionalDependencies,
    ...Object.fromEntries(nativePackages),
  }

  fs.writeFileSync(mainManifestPath, JSON.stringify(mainManifest, null, 2) + '\n')
  console.log(`✓ Updated main package.json with optionalDependencies`)
}

if (require.main === module) {
  main()
}

module.exports = { main }
